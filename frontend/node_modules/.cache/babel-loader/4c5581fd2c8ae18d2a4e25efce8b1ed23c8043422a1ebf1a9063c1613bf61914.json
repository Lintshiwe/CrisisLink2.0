{"ast":null,"code":"// LocationService.js - Handles geolocation, tracking, and distance calculations\nclass LocationService {\n  constructor() {\n    this.watchId = null;\n    this.currentPosition = null;\n    this.trackingCallbacks = new Set();\n    this.options = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 30000\n    };\n  }\n\n  // Get current location (one-time)\n  async getCurrentLocation() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n      navigator.geolocation.getCurrentPosition(position => {\n        const location = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: new Date(position.timestamp)\n        };\n        this.currentPosition = location;\n        resolve(location);\n      }, error => {\n        let errorMessage = 'Unknown location error';\n        switch (error.code) {\n          case error.PERMISSION_DENIED:\n            errorMessage = 'Location access denied by user';\n            break;\n          case error.POSITION_UNAVAILABLE:\n            errorMessage = 'Location information unavailable';\n            break;\n          case error.TIMEOUT:\n            errorMessage = 'Location request timed out';\n            break;\n        }\n        reject(new Error(errorMessage));\n      }, this.options);\n    });\n  }\n\n  // Start continuous location tracking\n  startTracking(callback) {\n    if (!navigator.geolocation) {\n      throw new Error('Geolocation is not supported by this browser');\n    }\n\n    // Add callback to set\n    if (callback) {\n      this.trackingCallbacks.add(callback);\n    }\n\n    // Start watching if not already started\n    if (!this.watchId) {\n      this.watchId = navigator.geolocation.watchPosition(position => {\n        const location = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          speed: position.coords.speed,\n          heading: position.coords.heading,\n          timestamp: new Date(position.timestamp)\n        };\n        this.currentPosition = location;\n\n        // Notify all callbacks\n        this.trackingCallbacks.forEach(callback => {\n          try {\n            callback(location);\n          } catch (error) {\n            console.error('Error in location callback:', error);\n          }\n        });\n      }, error => {\n        console.error('Location tracking error:', error);\n        this.trackingCallbacks.forEach(callback => {\n          try {\n            callback(null, error);\n          } catch (callbackError) {\n            console.error('Error in location error callback:', callbackError);\n          }\n        });\n      }, this.options);\n    }\n    return this.watchId;\n  }\n\n  // Stop location tracking\n  stopTracking(callback = null) {\n    if (callback) {\n      this.trackingCallbacks.delete(callback);\n    }\n\n    // If no more callbacks, stop watching\n    if (this.trackingCallbacks.size === 0 && this.watchId) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n\n  // Stop all tracking\n  stopAllTracking() {\n    if (this.watchId) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n    this.trackingCallbacks.clear();\n  }\n\n  // Calculate distance between two points (Haversine formula)\n  calculateDistance(lat1, lng1, lat2, lng2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLng = this.toRadians(lng2 - lng1);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return {\n      kilometers: distance,\n      meters: distance * 1000,\n      miles: distance * 0.621371\n    };\n  }\n\n  // Calculate bearing between two points\n  calculateBearing(lat1, lng1, lat2, lng2) {\n    const dLng = this.toRadians(lng2 - lng1);\n    const lat1Rad = this.toRadians(lat1);\n    const lat2Rad = this.toRadians(lat2);\n    const y = Math.sin(dLng) * Math.cos(lat2Rad);\n    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);\n    const bearing = this.toDegrees(Math.atan2(y, x));\n    return (bearing + 360) % 360; // Normalize to 0-360\n  }\n\n  // Check if user is within a certain radius of a point\n  isWithinRadius(targetLat, targetLng, radiusMeters, currentLat = null, currentLng = null) {\n    var _this$currentPosition, _this$currentPosition2;\n    const userLat = currentLat || ((_this$currentPosition = this.currentPosition) === null || _this$currentPosition === void 0 ? void 0 : _this$currentPosition.lat);\n    const userLng = currentLng || ((_this$currentPosition2 = this.currentPosition) === null || _this$currentPosition2 === void 0 ? void 0 : _this$currentPosition2.lng);\n    if (!userLat || !userLng) {\n      return false;\n    }\n    const distance = this.calculateDistance(userLat, userLng, targetLat, targetLng);\n    return distance.meters <= radiusMeters;\n  }\n\n  // Get address from coordinates (reverse geocoding)\n  async reverseGeocode(lat, lng) {\n    try {\n      const geocoder = new window.google.maps.Geocoder();\n      return new Promise((resolve, reject) => {\n        geocoder.geocode({\n          location: {\n            lat,\n            lng\n          }\n        }, (results, status) => {\n          if (status === 'OK') {\n            if (results[0]) {\n              resolve({\n                formatted_address: results[0].formatted_address,\n                address_components: results[0].address_components,\n                place_id: results[0].place_id\n              });\n            } else {\n              reject(new Error('No results found'));\n            }\n          } else {\n            reject(new Error(`Geocoder failed: ${status}`));\n          }\n        });\n      });\n    } catch (error) {\n      throw new Error(`Reverse geocoding failed: ${error.message}`);\n    }\n  }\n\n  // Get coordinates from address (forward geocoding)\n  async geocode(address) {\n    try {\n      const geocoder = new window.google.maps.Geocoder();\n      return new Promise((resolve, reject) => {\n        geocoder.geocode({\n          address\n        }, (results, status) => {\n          if (status === 'OK') {\n            if (results[0]) {\n              const location = results[0].geometry.location;\n              resolve({\n                lat: location.lat(),\n                lng: location.lng(),\n                formatted_address: results[0].formatted_address,\n                place_id: results[0].place_id\n              });\n            } else {\n              reject(new Error('No results found'));\n            }\n          } else {\n            reject(new Error(`Geocoder failed: ${status}`));\n          }\n        });\n      });\n    } catch (error) {\n      throw new Error(`Geocoding failed: ${error.message}`);\n    }\n  }\n\n  // Format coordinates for display\n  formatCoordinates(lat, lng, precision = 6) {\n    return {\n      decimal: `${lat.toFixed(precision)}, ${lng.toFixed(precision)}`,\n      dms: this.toDMS(lat, lng)\n    };\n  }\n\n  // Convert decimal degrees to degrees, minutes, seconds\n  toDMS(lat, lng) {\n    const formatDMS = (coordinate, isLat) => {\n      const absolute = Math.abs(coordinate);\n      const degrees = Math.floor(absolute);\n      const minutes = Math.floor((absolute - degrees) * 60);\n      const seconds = ((absolute - degrees - minutes / 60) * 3600).toFixed(2);\n      const direction = isLat ? coordinate >= 0 ? 'N' : 'S' : coordinate >= 0 ? 'E' : 'W';\n      return `${degrees}Â°${minutes}'${seconds}\"${direction}`;\n    };\n    return {\n      latitude: formatDMS(lat, true),\n      longitude: formatDMS(lng, false),\n      formatted: `${formatDMS(lat, true)} ${formatDMS(lng, false)}`\n    };\n  }\n\n  // Utility functions\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n  toDegrees(radians) {\n    return radians * (180 / Math.PI);\n  }\n\n  // Get current position (cached)\n  getCurrentPosition() {\n    return this.currentPosition;\n  }\n\n  // Check if geolocation is supported\n  static isSupported() {\n    return 'geolocation' in navigator;\n  }\n\n  // Check location permissions\n  async checkPermissions() {\n    if (!navigator.permissions) {\n      return 'unknown';\n    }\n    try {\n      const permission = await navigator.permissions.query({\n        name: 'geolocation'\n      });\n      return permission.state; // 'granted', 'denied', or 'prompt'\n    } catch (error) {\n      return 'unknown';\n    }\n  }\n\n  // Request location permissions\n  async requestPermissions() {\n    try {\n      const position = await this.getCurrentLocation();\n      return {\n        success: true,\n        position\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n}\n\n// Create singleton instance\nconst locationService = new LocationService();\nexport default locationService;","map":{"version":3,"names":["LocationService","constructor","watchId","currentPosition","trackingCallbacks","Set","options","enableHighAccuracy","timeout","maximumAge","getCurrentLocation","Promise","resolve","reject","navigator","geolocation","Error","getCurrentPosition","position","location","lat","coords","latitude","lng","longitude","accuracy","timestamp","Date","error","errorMessage","code","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","startTracking","callback","add","watchPosition","speed","heading","forEach","console","callbackError","stopTracking","delete","size","clearWatch","stopAllTracking","clear","calculateDistance","lat1","lng1","lat2","lng2","R","dLat","toRadians","dLng","a","Math","sin","cos","c","atan2","sqrt","distance","kilometers","meters","miles","calculateBearing","lat1Rad","lat2Rad","y","x","bearing","toDegrees","isWithinRadius","targetLat","targetLng","radiusMeters","currentLat","currentLng","_this$currentPosition","_this$currentPosition2","userLat","userLng","reverseGeocode","geocoder","window","google","maps","Geocoder","geocode","results","status","formatted_address","address_components","place_id","message","address","geometry","formatCoordinates","precision","decimal","toFixed","dms","toDMS","formatDMS","coordinate","isLat","absolute","abs","degrees","floor","minutes","seconds","direction","formatted","PI","radians","isSupported","checkPermissions","permissions","permission","query","name","state","requestPermissions","success","locationService"],"sources":["C:/Users/ntoam/Desktop/Projects/CrisisLink2.0/frontend/src/services/LocationService.js"],"sourcesContent":["// LocationService.js - Handles geolocation, tracking, and distance calculations\r\nclass LocationService {\r\n  constructor() {\r\n    this.watchId = null;\r\n    this.currentPosition = null;\r\n    this.trackingCallbacks = new Set();\r\n    this.options = {\r\n      enableHighAccuracy: true,\r\n      timeout: 10000,\r\n      maximumAge: 30000\r\n    };\r\n  }\r\n\r\n  // Get current location (one-time)\r\n  async getCurrentLocation() {\r\n    return new Promise((resolve, reject) => {\r\n      if (!navigator.geolocation) {\r\n        reject(new Error('Geolocation is not supported by this browser'));\r\n        return;\r\n      }\r\n\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => {\r\n          const location = {\r\n            lat: position.coords.latitude,\r\n            lng: position.coords.longitude,\r\n            accuracy: position.coords.accuracy,\r\n            timestamp: new Date(position.timestamp)\r\n          };\r\n          this.currentPosition = location;\r\n          resolve(location);\r\n        },\r\n        (error) => {\r\n          let errorMessage = 'Unknown location error';\r\n          switch (error.code) {\r\n            case error.PERMISSION_DENIED:\r\n              errorMessage = 'Location access denied by user';\r\n              break;\r\n            case error.POSITION_UNAVAILABLE:\r\n              errorMessage = 'Location information unavailable';\r\n              break;\r\n            case error.TIMEOUT:\r\n              errorMessage = 'Location request timed out';\r\n              break;\r\n          }\r\n          reject(new Error(errorMessage));\r\n        },\r\n        this.options\r\n      );\r\n    });\r\n  }\r\n\r\n  // Start continuous location tracking\r\n  startTracking(callback) {\r\n    if (!navigator.geolocation) {\r\n      throw new Error('Geolocation is not supported by this browser');\r\n    }\r\n\r\n    // Add callback to set\r\n    if (callback) {\r\n      this.trackingCallbacks.add(callback);\r\n    }\r\n\r\n    // Start watching if not already started\r\n    if (!this.watchId) {\r\n      this.watchId = navigator.geolocation.watchPosition(\r\n        (position) => {\r\n          const location = {\r\n            lat: position.coords.latitude,\r\n            lng: position.coords.longitude,\r\n            accuracy: position.coords.accuracy,\r\n            speed: position.coords.speed,\r\n            heading: position.coords.heading,\r\n            timestamp: new Date(position.timestamp)\r\n          };\r\n          \r\n          this.currentPosition = location;\r\n          \r\n          // Notify all callbacks\r\n          this.trackingCallbacks.forEach(callback => {\r\n            try {\r\n              callback(location);\r\n            } catch (error) {\r\n              console.error('Error in location callback:', error);\r\n            }\r\n          });\r\n        },\r\n        (error) => {\r\n          console.error('Location tracking error:', error);\r\n          this.trackingCallbacks.forEach(callback => {\r\n            try {\r\n              callback(null, error);\r\n            } catch (callbackError) {\r\n              console.error('Error in location error callback:', callbackError);\r\n            }\r\n          });\r\n        },\r\n        this.options\r\n      );\r\n    }\r\n\r\n    return this.watchId;\r\n  }\r\n\r\n  // Stop location tracking\r\n  stopTracking(callback = null) {\r\n    if (callback) {\r\n      this.trackingCallbacks.delete(callback);\r\n    }\r\n\r\n    // If no more callbacks, stop watching\r\n    if (this.trackingCallbacks.size === 0 && this.watchId) {\r\n      navigator.geolocation.clearWatch(this.watchId);\r\n      this.watchId = null;\r\n    }\r\n  }\r\n\r\n  // Stop all tracking\r\n  stopAllTracking() {\r\n    if (this.watchId) {\r\n      navigator.geolocation.clearWatch(this.watchId);\r\n      this.watchId = null;\r\n    }\r\n    this.trackingCallbacks.clear();\r\n  }\r\n\r\n  // Calculate distance between two points (Haversine formula)\r\n  calculateDistance(lat1, lng1, lat2, lng2) {\r\n    const R = 6371; // Earth's radius in kilometers\r\n    const dLat = this.toRadians(lat2 - lat1);\r\n    const dLng = this.toRadians(lng2 - lng1);\r\n    \r\n    const a = \r\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n      Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * \r\n      Math.sin(dLng / 2) * Math.sin(dLng / 2);\r\n    \r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    const distance = R * c;\r\n    \r\n    return {\r\n      kilometers: distance,\r\n      meters: distance * 1000,\r\n      miles: distance * 0.621371\r\n    };\r\n  }\r\n\r\n  // Calculate bearing between two points\r\n  calculateBearing(lat1, lng1, lat2, lng2) {\r\n    const dLng = this.toRadians(lng2 - lng1);\r\n    const lat1Rad = this.toRadians(lat1);\r\n    const lat2Rad = this.toRadians(lat2);\r\n    \r\n    const y = Math.sin(dLng) * Math.cos(lat2Rad);\r\n    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - \r\n              Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);\r\n    \r\n    const bearing = this.toDegrees(Math.atan2(y, x));\r\n    return (bearing + 360) % 360; // Normalize to 0-360\r\n  }\r\n\r\n  // Check if user is within a certain radius of a point\r\n  isWithinRadius(targetLat, targetLng, radiusMeters, currentLat = null, currentLng = null) {\r\n    const userLat = currentLat || this.currentPosition?.lat;\r\n    const userLng = currentLng || this.currentPosition?.lng;\r\n    \r\n    if (!userLat || !userLng) {\r\n      return false;\r\n    }\r\n    \r\n    const distance = this.calculateDistance(userLat, userLng, targetLat, targetLng);\r\n    return distance.meters <= radiusMeters;\r\n  }\r\n\r\n  // Get address from coordinates (reverse geocoding)\r\n  async reverseGeocode(lat, lng) {\r\n    try {\r\n      const geocoder = new window.google.maps.Geocoder();\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        geocoder.geocode(\r\n          { location: { lat, lng } },\r\n          (results, status) => {\r\n            if (status === 'OK') {\r\n              if (results[0]) {\r\n                resolve({\r\n                  formatted_address: results[0].formatted_address,\r\n                  address_components: results[0].address_components,\r\n                  place_id: results[0].place_id\r\n                });\r\n              } else {\r\n                reject(new Error('No results found'));\r\n              }\r\n            } else {\r\n              reject(new Error(`Geocoder failed: ${status}`));\r\n            }\r\n          }\r\n        );\r\n      });\r\n    } catch (error) {\r\n      throw new Error(`Reverse geocoding failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Get coordinates from address (forward geocoding)\r\n  async geocode(address) {\r\n    try {\r\n      const geocoder = new window.google.maps.Geocoder();\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        geocoder.geocode(\r\n          { address },\r\n          (results, status) => {\r\n            if (status === 'OK') {\r\n              if (results[0]) {\r\n                const location = results[0].geometry.location;\r\n                resolve({\r\n                  lat: location.lat(),\r\n                  lng: location.lng(),\r\n                  formatted_address: results[0].formatted_address,\r\n                  place_id: results[0].place_id\r\n                });\r\n              } else {\r\n                reject(new Error('No results found'));\r\n              }\r\n            } else {\r\n              reject(new Error(`Geocoder failed: ${status}`));\r\n            }\r\n          }\r\n        );\r\n      });\r\n    } catch (error) {\r\n      throw new Error(`Geocoding failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Format coordinates for display\r\n  formatCoordinates(lat, lng, precision = 6) {\r\n    return {\r\n      decimal: `${lat.toFixed(precision)}, ${lng.toFixed(precision)}`,\r\n      dms: this.toDMS(lat, lng)\r\n    };\r\n  }\r\n\r\n  // Convert decimal degrees to degrees, minutes, seconds\r\n  toDMS(lat, lng) {\r\n    const formatDMS = (coordinate, isLat) => {\r\n      const absolute = Math.abs(coordinate);\r\n      const degrees = Math.floor(absolute);\r\n      const minutes = Math.floor((absolute - degrees) * 60);\r\n      const seconds = ((absolute - degrees - minutes / 60) * 3600).toFixed(2);\r\n      \r\n      const direction = isLat \r\n        ? (coordinate >= 0 ? 'N' : 'S')\r\n        : (coordinate >= 0 ? 'E' : 'W');\r\n      \r\n      return `${degrees}Â°${minutes}'${seconds}\"${direction}`;\r\n    };\r\n    \r\n    return {\r\n      latitude: formatDMS(lat, true),\r\n      longitude: formatDMS(lng, false),\r\n      formatted: `${formatDMS(lat, true)} ${formatDMS(lng, false)}`\r\n    };\r\n  }\r\n\r\n  // Utility functions\r\n  toRadians(degrees) {\r\n    return degrees * (Math.PI / 180);\r\n  }\r\n\r\n  toDegrees(radians) {\r\n    return radians * (180 / Math.PI);\r\n  }\r\n\r\n  // Get current position (cached)\r\n  getCurrentPosition() {\r\n    return this.currentPosition;\r\n  }\r\n\r\n  // Check if geolocation is supported\r\n  static isSupported() {\r\n    return 'geolocation' in navigator;\r\n  }\r\n\r\n  // Check location permissions\r\n  async checkPermissions() {\r\n    if (!navigator.permissions) {\r\n      return 'unknown';\r\n    }\r\n\r\n    try {\r\n      const permission = await navigator.permissions.query({ name: 'geolocation' });\r\n      return permission.state; // 'granted', 'denied', or 'prompt'\r\n    } catch (error) {\r\n      return 'unknown';\r\n    }\r\n  }\r\n\r\n  // Request location permissions\r\n  async requestPermissions() {\r\n    try {\r\n      const position = await this.getCurrentLocation();\r\n      return { success: true, position };\r\n    } catch (error) {\r\n      return { success: false, error: error.message };\r\n    }\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst locationService = new LocationService();\r\n\r\nexport default locationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}